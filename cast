#!/usr/bin/env ruby

require 'optparse'
require 'net/http'
require 'cgi'
require 'simple_upnp'
require 'pp'

class CastOptions < OptionParser
  attr_accessor :name, :host, :port, :stop, :status, :debug
  def initialize
    @name = nil
    @host = nil
    @port = 8008
    @stop = []
    @status = []
    @debug = false
    super do |opts|
      opts.on('-?', '--help', 'Display usage') do
        puts opts
        exit
      end
      opts.on('-t', '--to DEVICE', 'Choose discovered device by name') do |arg|
        @name = arg
      end
      opts.on('-h', '--host HOST', 'Use host instead of doing discovery') do |arg|
        @host = arg
      end
      opts.on('-p', '--port PORT', 'Specify port for host') do |arg|
        @port = arg
      end
      opts.on('-s', '--stop APP', 'Stop app') do |arg|
        @stop << arg
      end
      opts.on('-q', '--status APP', 'Get status of app') do |arg|
        @status << arg
      end
      opts.on('--debug', 'Print device debug info') do
        @debug = true
      end
    end
    parse!
  end
end

class CastApp
  # Any app we know about must override these two class methods.
  # `can_play?` tells us if the given URI is something we recognize.
  # `params` is the hash of params to pass to the Chromecast app for
  # that URI.
  def self.can_play?(uri)
    false
  end
  def self.params(uri)
    {}
  end

  def initialize(base_uri)
    @uri = URI.parse(base_uri).tap {|uri| uri.path = "/apps/#{self.class.name}" }
  end
  # TODO: check docs for the official terminology on this triple
  def start(params)
    puts "starting: #{@uri}, #{params.inspect}"
    Net::HTTP.post_form(@uri, params)
  end
  def status
    Net::HTTP.get(@uri)
  end
  def stop
    Net::HTTP.new(@uri.host, @uri.port).delete(@uri.path)
  end
end

class YouTube < CastApp
  def self.can_play?(uri)
    !!video_id(uri)
  end
  def self.params(uri)
    {'v' => video_id(uri) }
  end
  def self.video_id(uri)
    case uri
    when /^https?:\/\/youtu\.be\//
      URI.parse(uri).path.sub('/', '')
    when /^https?:\/\/(www\.)?youtube\.com\/embed\//
      URI.parse(uri).path.sub('/embed/', '')
    when /^https?:\/\/(www\.)?youtube\.com\/v\//
      URI.parse(uri).path.sub('/v/', '')
    when /^https?:\/\/(www\.)?youtube\.com\/watch\?/, /^\/watch\?/
      CGI.parse(URI.parse(uri).query)['v'].first
    else
      nil
    end
  end
end

class Netflix < CastApp
  # Netflix doesn't work. You need to open a websocket to the device and
  # send some encrypted stuff (possibly for as long as you want the
  # title to keep playing? It keeps sending stuff, but that may just be
  # to keep the time updated on the casting device). If you want to try
  # reversing the protocol, the Chrome extension's websocket traffic can
  # be observed in the dev tools.
  def self.can_play?(uri)
    # !!video_id(uri)
    false
  end
  def self.params(uri)
    {
      'intent' => 'play',
      'titleid' => "http://api.netflix.com/catalog/titles/movies/#{video_id(uri)}",
    }
  end
  def self.video_id(uri)
    case uri
    when /^http:\/\/movies\.netflix\.com\/WiMovie\/.+?\/(\d+)/
      $1
    else
      nil
    end
  end
end

APP_CLASSES = {
  "YouTube" => YouTube,
  "Netflix" => Netflix,
}

class CastDevice
  def initialize(options)
    if options.host && options.port
      @device_base_uri = URI.parse("http://#{options.host}:#{options.port}")
    else
      SimpleUpnp::Discovery.find do |device|
        device_info = device.to_json(true) # note: not actually JSON
        device_type = device_info['root']['device']['deviceType'] rescue nil
        if device_type && device_type.start_with?('urn:dial-multiscreen-org:')
          friendly_name = device_info['root']['device']['friendlyName'] rescue nil
          if options.name.nil? || friendly_name == options.name
            @device_info = device_info
            @device_base_uri = device_info['root']['URLBase'] rescue nil
            break
          end
        end
      end
    end
    options.stop.each do |app|
      APP_CLASSES[app].new(@device_base_uri).stop
    end
    options.status.each do |app|
      puts APP_CLASSES[app].new(@device_base_uri).status
    end
  end
  def found?
    !!@device_base_uri
  end
  def cast(uri)
    APP_CLASSES.each do |app_name, app_class|
      if app_class.can_play?(uri)
        app_class.new(@device_base_uri).start(app_class.params(uri))
        return
      end
    end
    puts "No app matched #{uri}"
  end
  def show_info
    puts "Chromecast device at #{@device_base_uri}"
    pp @device_info
  end
end

options = CastOptions.new
device = CastDevice.new(options)

if device.found?
  device.show_info if options.debug
  ARGV.each do |arg|
    device.cast(arg)
  end
else
  STDERR.puts "Can't find a device"
  exit 1
end
