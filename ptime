#!/usr/bin/env ruby

require 'time'
require 'optparse'
require 'ostruct'

def parse_args(&blk)
  OpenStruct.new.tap do |o|
    OptionParser.new.instance_exec(o, &blk).parse!
  end
end

options = parse_args do |opts|
  opts.mode = :iso
  on('-i', '--iso') { opts.mode = :iso }
  on('-f', '--format F') {|arg| opts.mode = :format; opts.format = arg }
  on('-m', '--minutes') { opts.mode = :diff; opts.unit = 60 }
  on('-h', '--hours') { opts.mode = :diff; opts.unit = 3600 }
  on('-d', '--days') { opts.mode = :diff; opts.unit = 86400 }
  on('-o', '--round R') {|arg| opts.round = arg }
  on('-p', '--posix') { opts.mode = :format; opts.format = '%Y%m%d%H%M.%S' }
  on('-r', '--reference') { opts.reference = true }
  on('-v', '--verbose') { opts.verbose = true }
end

class Time
  def self.ncsa_clf(str)
    strptime(str, '%d/%b/%Y:%H:%M:%S %z')
  end
end

def parse_time(str)
  t = nil
  # If we know Chronic is required, skip the faster strategies
  unless str =~ /today|yesterday|ago|hence|before|from|this|last/
    %i[rfc2822 httpdate xmlschema ncsa_clf parse].each do |m|
      begin
        t ||= Time.send(m, str)
        break
      rescue ArgumentError
      end
    end
  end
  t ||= try_chronic(str)
end

def try_chronic(str)
  require 'chronic'
  Chronic.parse(str)
rescue LoadError
  nil
end

ARGV.each do |arg|
  t = options.reference ? File.mtime(arg) : parse_time(arg)
  if t
    s = case options.mode
    when :iso
      t.iso8601
    when :format
      t.strftime(options.format)
    when :diff
      diff = ((Time.now - t) / options.unit.to_f).abs
      case options.round
      when 'down', 'floor'
        diff.floor
      when 'up', 'ceil'
        diff.ceil
      else
        diff.round(options.round.to_i)
      end
    end
    s += "\t#{arg}" if options.verbose
    puts s
  else
    STDERR.puts 'All parsing methods failed'
    puts arg
  end
end
