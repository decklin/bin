#!/usr/bin/ruby

require 'optparse'

# Run a command n times, spread over some duration with randomly-divided
# sleeps (by default, 1 time over 1 hour).
#
# In most cases, this script will take less than the specified duration
# to complete: once the command has run for the final time, the script
# exits immediately. However, if the command itself takes a long time,
# and subsequent invocations are "behind schedule", then (1) sleeping
# will be skipped (2) the entire script execution may take longer than
# the specified total duration. So, don't make any assumptions about how
# long this script will take to run.
#
# The lengths of the sleeps are calculated by generating n+1 random
# numbers with a range from fudge to fudge+1 and scaling the available
# time. So, if you decrease fudge to 0, some sleeps could literally be
# 0, and if you increase it to a very large number, all sleeps will be
# very close to equal. By default the longest sleep can be 5x the
# shortest sleep.

duration = 3600
n_times = 1
fudge = 0.25
verbose = false

OptionParser.new do |op|
  op.on('-d', '--duration SECONDS') {|a| duration = a.to_f }
  op.on('-n', '--times TIMES') {|a| n_times = a.to_i }
  op.on('-f', '--fudge FACTOR') {|a| fudge = a.to_f }
  op.on('-v', '--verbose') {|a| verbose = true }
end.parse!

gap_scaling_factors = (0..n_times).map { fudge + rand }
scaling_sum = gap_scaling_factors.reduce(&:+)
gaps = gap_scaling_factors.map {|sf| duration * sf / scaling_sum }
gaps.pop

elapsed = 0
gaps.each do |gap|
  until_next_gap = gap - elapsed
  if until_next_gap >= 0
    STDERR.puts "sched: sleeping #{until_next_gap.round(2)}" if verbose
    sleep(until_next_gap)
  else
    STDERR.puts "sched: warning: not sleeping, behind #{-until_next_gap.round(2)}"
  end
  start_time = Time.now
  system(*ARGV)
  elapsed = Time.now - start_time
end
